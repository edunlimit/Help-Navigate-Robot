# Help-Navigate-Robot

## The Object and a goal of the project
The object of this project is to help robots navigate by predicting what surfaces the robot is walking on using IMU sensor data. This project would be most helpful in cases where robots are remotely controlled and standing on unknown places. Real life example would be Curiosity robot sent to Mars where humans can not tell what kind of surface the robot is walking on. Using IMU sensor data that Curiosity robots send back to earth, scientists would be able to tell what kind of surfaces are closest to the surface of Mars. 

## Main contents and the title of the project
Title of the project is “Help Navigate Robots”. This project consists of exploratory data analysis of the data, feature engineering, model implementation, model selection, and prediction part. In EDA part, I looked at information of each of the columns to see if any values are missing and the size of the dataframe. Then used .describe() method to look at statistics such as min, max, mean, std, and quartiles of each column to see how data are distributed. To look at if there are the same number of tests done on each surface, I grouped data into the series_id column which represents test number and verified that for each test, 127 measurements were taken. Then correlation heat map was created (*Figure1) to see how each column are correlated to each other and found out that orientation_X and W, orientation_Y and Z, and angular velocity_Y and Z are closely related. I searched how these quaternions are calculated and was able to know why. Next thing I did was to look at distributions of target variables which is surfaces. I looked at the total number of classes, the number of classes for each class and plotted a bar graph to visually see distributions for each class. For the last step of EDA, I looked at histograms of all the features to see any outliers and how data are distributed. After EDA, I did a feature engineering to add more features the model can study. Feature engineering part is explained later in this letter. For choosing a model, I tried random forest classifier and LightGBM classifier to compare their scores and choose a better model. For both models, I used grid search to find the best parameters and stratified K fold cross validation was used. At the end, I also did a feature selection to see if the score will improve. As a result, random forest classifier scored higher in the test set. I think it is because there were not many data, LightGBM suffered an overfitting problem, and while working on the data, I found out that this data set is prone to overfitting. By conducting feature selection which is known for reducing overfitting and calculation time, cross-validation score went up, but submission score went down which could mean that features left with greater feature importance might have introduced more noise which led into more overfitting. As a result, cross-validation score of 0.88 was achieved with a submission score of 0.72. Considering the top submission score on the leader board of 0.75, my submission score would increase more by dealing with the overfitting problem.

## Which part do you think the most creative and making effort in the project?

Creativity is essential in data analysis and machine learning, but if I must choose one part of this project, I would say the feature engineering part was the most important, required creativity, and improved accuracy of the model significantly. Since this project’s data was IMU sensor data, physics knowledge was required. The data had 127 measurements for each test so to decrease noises in data, I implemented mean, range, standard deviation, kurtosis, mean of absolute max and min, mean absolute change, mean change of absolute change, for each test. By doing so, I was able to decrease noises and gained more features. Also, orientation data was in quaternions with x,y,z,w so I converted orientations into Euler angle of x, y, z. Angular velocity, linear acceleration, Euler angle was first summed up using the root of the sum of squares (RSS). Using total angular velocity and total angle, total time was found using angular velocity formula and using total time and total linear acceleration, total linear velocity was added to features. I also added relationships of acceleration vs velocity, angle vs velocity and linear velocity vs linear acceleration. In the end, minimum and maximum values for each test, sum, quartiles were removed since it improved the accuracy of the models. 

